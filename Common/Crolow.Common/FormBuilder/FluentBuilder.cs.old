// DynamicForms.Typed.cs
// Strongly-typed form definition + fluent builder
// - NO dynamic objects
// - NO JsonElement
// - NO anonymous configs
// - Editor configs are typed (classes/records)
// - Validator configs are typed (classes/records)
// - Supports embedded forms (form inside form)
//
// NOTE: To keep heterogeneous fields in a single panel list, the panel stores IReadOnlyList<IFieldDefinition>.
//       Individual fields remain fully typed (FieldDefinition<TValue,TEditorConfig>).

using Crolow.Apps.Common.FormBuilder;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace DynamicForms.Typed;

// ==========================================================
// 1) Core containers (serializable POCO/records)
// ==========================================================

public sealed record FormDefinition(
    string SchemaVersion,
    string? Title,
    IReadOnlyList<TabDefinition> Tabs
);

public sealed record TabDefinition(
    string Title,
    string? Icon,
    IReadOnlyList<SectionDefinition> Sections
);

public sealed record SectionDefinition(
    string Title,
    bool Collapsible,
    bool InitiallyExpanded,
    string? Description,
    IReadOnlyList<PanelDefinition> Panels
);

public sealed record PanelDefinition(
    string? Title,
    string? Description,
    PanelLayout Layout,
    PanelVisual Visual,
    IReadOnlyList<IFieldDefinition> Fields
);

public sealed record PanelLayout(int Columns, int ColumnGap = 2);

public sealed record PanelVisual(
    bool Outlined = true,
    int Elevation = 0,
    bool Dense = false,
    string? CssClass = null
);

public enum ValueKind
{
    String,
    Number,
    Boolean,
    Date,
    Time,
    DateTime,
    Enum,
    Object,
    Collection
}

// ==========================================================
// 2) Fields (heterogeneous list via interface, no dynamic configs)
// ==========================================================

public interface IFieldDefinition
{
    string Name { get; }
    string PropertyPath { get; }
    string? Label { get; }
    string? Description { get; }
    bool Disabled { get; }
    bool ReadOnly { get; }
}

public enum EmbeddedFormPresentation
{
    Inline,
    Panel,
    Section,
    Tab
}

public sealed record EmbeddedFormFieldDefinition(
    string Name,
    string PropertyPath,
    string? Label,
    string? Description,
    bool Disabled,
    bool ReadOnly,
    FormDefinition EmbeddedForm,
    EmbeddedFormPresentation Presentation
) : IFieldDefinition;

/// <summary>
/// Strongly-typed field definition:
/// - TValue: bound property type
/// - TEditorConfig: editor configuration type
/// - Validators: typed configs (no JsonElement/object)
/// </summary>
public sealed record FieldDefinition<TValue, TEditorConfig>(
    string Name,
    string PropertyPath,
    string? Label,
    string? Description,
    bool Disabled,
    bool ReadOnly,
    bool Required,
    EditorDefinition<TEditorConfig> Editor,
    IReadOnlyList<IValidatorDefinition<TValue>> Validators
) : IFieldDefinition
    where TEditorConfig : class, IEditorConfig;

// ==========================================================
// 3) Editors (typed configs)
// ==========================================================

public interface IEditorConfig { }

public sealed record EditorDefinition<TConfig>(
    ValueKind ValueKind,
    string Key,
    TConfig Config
) where TConfig : class, IEditorConfig;


// ==========================================================
// 4) Validators (typed configs, no dynamic)
// ==========================================================

public interface IValidatorConfig { }

public interface IValidatorDefinition<TValue>
{
    string Key { get; }
    string Message { get; }
}

public interface IValidatorDefinition<TValue, out TConfig> : IValidatorDefinition<TValue>
    where TConfig : class, IValidatorConfig
{
    TConfig Config { get; }
}

public sealed record ValidatorDefinition<TValue, TConfig>(
    string Key,
    string Message,
    TConfig Config
) : IValidatorDefinition<TValue, TConfig>
    where TConfig : class, IValidatorConfig;


// ==========================================================
// 5) Registries (typed; no dynamic config, but internally stores descriptors)
// ==========================================================

public sealed record EditorDescriptor<TConfig>(
    string Key,
    ValueKind ValueKind,
    TConfig DefaultConfig
) where TConfig : class, IEditorConfig;

public interface IEditorRegistry
{
    EditorDescriptor<TConfig> Get<TConfig>(string key) where TConfig : class, IEditorConfig;
}

public sealed class EditorRegistry : IEditorRegistry
{
    // Heterogeneous storage of typed descriptors.
    private readonly Dictionary<string, object> _map = new(StringComparer.OrdinalIgnoreCase);

    // Existing API still supported
    public EditorRegistry Register<TConfig>(EditorDescriptor<TConfig> descriptor)
        where TConfig : class, IEditorConfig
    {
        _map[descriptor.Key] = descriptor;
        return this;
    }

    // NEW: convenience overload (most used)
    public EditorRegistry Register<TConfig>(string key, ValueKind valueKind, TConfig defaultConfig)
        where TConfig : class, IEditorConfig
        => Register(new EditorDescriptor<TConfig>(key, valueKind, defaultConfig));

    // NEW: convenience overload for parameterless configs (new())
    public EditorRegistry Register<TConfig>(string key, ValueKind valueKind)
        where TConfig : class, IEditorConfig, new()
        => Register(new EditorDescriptor<TConfig>(key, valueKind, new TConfig()));

    public EditorDescriptor<TConfig> Get<TConfig>(string key)
        where TConfig : class, IEditorConfig
    {
        if (!_map.TryGetValue(key, out var obj))
            throw new InvalidOperationException($"Editor '{key}' is not registered.");

        if (obj is not EditorDescriptor<TConfig> typed)
            throw new InvalidOperationException(
                $"Editor '{key}' is registered but with a different config type. Expected {typeof(TConfig).Name}.");

        return typed;
    }
}

public sealed record ValidatorDescriptor<TValue, TConfig>(
    string Key,
    TConfig DefaultConfig
) where TConfig : class, IValidatorConfig;

public interface IValidatorRegistry
{
    ValidatorDescriptor<TValue, TConfig> Get<TValue, TConfig>(string key)
        where TConfig : class, IValidatorConfig;
}

public sealed class ValidatorRegistry : IValidatorRegistry
{
    private readonly Dictionary<string, object> _map = new(StringComparer.OrdinalIgnoreCase);

    public ValidatorRegistry Register<TValue, TConfig>(ValidatorDescriptor<TValue, TConfig> descriptor)
        where TConfig : class, IValidatorConfig
    {
        _map[descriptor.Key] = descriptor;
        return this;
    }

    public ValidatorDescriptor<TValue, TConfig> Get<TValue, TConfig>(string key)
        where TConfig : class, IValidatorConfig
    {
        if (!_map.TryGetValue(key, out var obj))
            throw new InvalidOperationException($"Validator '{key}' is not registered.");

        if (obj is not ValidatorDescriptor<TValue, TConfig> typed)
            throw new InvalidOperationException($"Validator '{key}' is registered but with a different value/config type.");

        return typed;
    }
}

// ==========================================================
// 6) Fluent Builder
// ==========================================================

public sealed class FormBuilder<TModel>
{
    private const string Schema = "1.0";
    private readonly IEditorRegistry _editors;
    private readonly IValidatorRegistry _validators;

    private string? _title;
    private readonly List<TabDefinition> _tabs = new();

    private FormBuilder(IEditorRegistry editors, IValidatorRegistry validators)
    {
        _editors = editors;
        _validators = validators;
    }

    public static FormBuilder<TModel> Create(IEditorRegistry editors, IValidatorRegistry validators, string? title = null)
        => new(editors, validators) { _title = title };

    public FormBuilder<TModel> Title(string title) { _title = title; return this; }

    public FormBuilder<TModel> Tab(string title, Action<TabBuilder<TModel>> build, string? icon = null)
    {
        var tb = new TabBuilder<TModel>(_editors, _validators, title, icon);
        build(tb);
        _tabs.Add(tb.Build());
        return this;
    }

    public FormDefinition Build() => new(Schema, _title, _tabs);
}

public sealed class TabBuilder<TModel>
{
    private readonly IEditorRegistry _editors;
    private readonly IValidatorRegistry _validators;
    private readonly string _title;
    private readonly string? _icon;
    private readonly List<SectionDefinition> _sections = new();

    internal TabBuilder(IEditorRegistry editors, IValidatorRegistry validators, string title, string? icon)
    {
        _editors = editors;
        _validators = validators;
        _title = title;
        _icon = icon;
    }

    public TabBuilder<TModel> Section(
        string title,
        Action<SectionBuilder<TModel>> build,
        bool collapsible = true,
        bool initiallyExpanded = true,
        string? description = null)
    {
        var sb = new SectionBuilder<TModel>(_editors, _validators, title, collapsible, initiallyExpanded, description);
        build(sb);
        _sections.Add(sb.Build());
        return this;
    }

    internal TabDefinition Build() => new(_title, _icon, _sections);
}

public sealed class SectionBuilder<TModel>
{
    private readonly IEditorRegistry _editors;
    private readonly IValidatorRegistry _validators;
    private readonly string _title;
    private readonly bool _collapsible;
    private readonly bool _expanded;
    private readonly string? _description;
    private readonly List<PanelDefinition> _panels = new();

    internal SectionBuilder(IEditorRegistry editors, IValidatorRegistry validators, string title, bool collapsible, bool expanded, string? description)
    {
        _editors = editors;
        _validators = validators;
        _title = title;
        _collapsible = collapsible;
        _expanded = expanded;
        _description = description;
    }

    public SectionBuilder<TModel> Panel(Action<PanelBuilder<TModel>> build, string? title = null, string? description = null)
    {
        var pb = new PanelBuilder<TModel>(_editors, _validators, title, description);
        build(pb);
        _panels.Add(pb.Build());
        return this;
    }

    internal SectionDefinition Build() => new(_title, _collapsible, _expanded, _description, _panels);
}

public sealed class PanelBuilder<TModel>
{
    private readonly IEditorRegistry _editors;
    private readonly IValidatorRegistry _validators;

    private readonly string? _title;
    private readonly string? _description;
    private PanelLayout _layout = new(1, 2);
    private PanelVisual _visual = new();
    private readonly List<IFieldDefinition> _fields = new();

    internal PanelBuilder(IEditorRegistry editors, IValidatorRegistry validators, string? title, string? description)
    {
        _editors = editors;
        _validators = validators;
        _title = title;
        _description = description;
    }

    public PanelBuilder<TModel> Columns(int columns, int gap = 2)
    {
        _layout = new PanelLayout(Math.Max(1, columns), Math.Max(0, gap));
        return this;
    }

    public PanelBuilder<TModel> Visual(bool outlined = true, int elevation = 0, bool dense = false, string? cssClass = null)
    {
        _visual = new PanelVisual(outlined, elevation, dense, cssClass);
        return this;
    }

    /// <summary>
    /// Strongly typed field creation.
    /// You must specify TEditorConfig so configs remain typed and no dynamic objects are needed.
    /// </summary>
    public PanelBuilder<TModel> Field<TValue, TEditorConfig>(
        string name,
        Expression<Func<TModel, TValue>> bind,
        Action<FieldBuilder<TModel, TValue, TEditorConfig>> build)
        where TEditorConfig : class, IEditorConfig
    {
        var fb = new FieldBuilder<TModel, TValue, TEditorConfig>(_editors, _validators, name, bind);
        build(fb);
        _fields.Add(fb.Build());
        return this;
    }

    public PanelBuilder<TModel> EmbeddedForm<TNested>(
        string name,
        Expression<Func<TModel, TNested>> bind,
        FormDefinition embeddedForm,
        Action<EmbeddedFormFieldBuilder>? build = null)
    {
        var eb = new EmbeddedFormFieldBuilder(name, PropertyPath.FromExpression(bind), embeddedForm);
        build?.Invoke(eb);
        _fields.Add(eb.Build());
        return this;
    }

    internal PanelDefinition Build() => new(_title, _description, _layout, _visual, _fields);
}

public sealed class FieldBuilder<TModel, TValue, TEditorConfig>
    where TEditorConfig : class, IEditorConfig
{
    private readonly IEditorRegistry _editors;
    private readonly IValidatorRegistry _validators;
    private readonly string _name;
    private readonly Expression<Func<TModel, TValue>> _expr;

    private string? _label;
    private string? _description;
    private bool _disabled;
    private bool _readOnly;
    private bool _required;

    private EditorDefinition<TEditorConfig>? _editor;
    private readonly List<IValidatorDefinition<TValue>> _validatorDefs = new();

    internal FieldBuilder(IEditorRegistry editors, IValidatorRegistry validators, string name, Expression<Func<TModel, TValue>> expr)
    {
        _editors = editors;
        _validators = validators;
        _name = name;
        _expr = expr;
    }

    public FieldBuilder<TModel, TValue, TEditorConfig> Label(string label) { _label = label; return this; }
    public FieldBuilder<TModel, TValue, TEditorConfig> Description(string description) { _description = description; return this; }
    public FieldBuilder<TModel, TValue, TEditorConfig> Disabled(bool disabled = true) { _disabled = disabled; return this; }
    public FieldBuilder<TModel, TValue, TEditorConfig> ReadOnly(bool readOnly = true) { _readOnly = readOnly; return this; }

    public FieldBuilder<TModel, TValue, TEditorConfig> Required(bool required = true, string message = "Required")
    {
        _required = required;
        if (required && _validatorDefs.All(v => v.Key != "required"))
        {
            _validatorDefs.Insert(0, new ValidatorDefinition<TValue, EmptyValidatorConfig>(
                Key: "required",
                Message: message,
                Config: new EmptyValidatorConfig()
            ));
        }
        return this;
    }

    // ----------------------------------------------------------
    // USEEDITOR: THIS IS WHERE IT BELONGS (inside FieldBuilder)
    // ----------------------------------------------------------
    public FieldBuilder<TModel, TValue, TEditorConfig> UseEditor(string key, TEditorConfig? config = null)
    {
        var descriptor = _editors.Get<TEditorConfig>(key);
        _editor = new EditorDefinition<TEditorConfig>(
            ValueKind: descriptor.ValueKind,
            Key: descriptor.Key,
            Config: config ?? descriptor.DefaultConfig
        );
        return this;
    }

    // ----------------------------------------------------------
    // Typed validators (no dynamic objects)
    // ----------------------------------------------------------

    public FieldBuilder<TModel, TValue, TEditorConfig> UseValidator<TValConfig>(
        string key,
        string message,
        TValConfig? config = null)
        where TValConfig : class, IValidatorConfig
    {
        var d = _validators.Get<TValue, TValConfig>(key);
        _validatorDefs.Add(new ValidatorDefinition<TValue, TValConfig>(
            Key: d.Key,
            Message: message,
            Config: config ?? d.DefaultConfig
        ));
        return this;
    }

    public FieldBuilder<TModel, TValue, TEditorConfig> MinLength(int min, string? message = null)
        => UseValidator("minLength", message ?? $"Minimum length is {min}", new MinLengthConfig(min));

    public FieldBuilder<TModel, TValue, TEditorConfig> MaxLength(int max, string? message = null)
        => UseValidator("maxLength", message ?? $"Maximum length is {max}", new MaxLengthConfig(max));

    public FieldBuilder<TModel, TValue, TEditorConfig> Regex(string pattern, string? message = null)
        => UseValidator("regex", message ?? "Invalid format", new RegexConfig(pattern));

    public FieldBuilder<TModel, TValue, TEditorConfig> Range(decimal min, decimal max, string? message = null)
        => UseValidator("range", message ?? $"Must be between {min} and {max}", new RangeDecimalConfig(min, max));

    internal FieldDefinition<TValue, TEditorConfig> Build()
    {
        var path = PropertyPath.FromExpression(_expr);

        if (_editor is null)
            throw new InvalidOperationException($"Field '{_name}' has no editor. Call UseEditor(key, config).");

        // Keep required flag consistent with required validator
        if (_required && _validatorDefs.All(v => v.Key != "required"))
        {
            _validatorDefs.Insert(0, new ValidatorDefinition<TValue, EmptyValidatorConfig>(
                Key: "required",
                Message: "Required",
                Config: new EmptyValidatorConfig()
            ));
        }

        return new FieldDefinition<TValue, TEditorConfig>(
            Name: _name,
            PropertyPath: path,
            Label: _label ?? _name,
            Description: _description,
            Disabled: _disabled,
            ReadOnly: _readOnly,
            Required: _required,
            Editor: _editor,
            Validators: _validatorDefs.ToList()
        );
    }
}

public sealed class EmbeddedFormFieldBuilder
{
    private readonly string _name;
    private readonly string _path;
    private readonly FormDefinition _embedded;

    private string? _label;
    private string? _description;
    private bool _disabled;
    private bool _readOnly;
    private EmbeddedFormPresentation _presentation = EmbeddedFormPresentation.Inline;

    internal EmbeddedFormFieldBuilder(string name, string path, FormDefinition embedded)
    {
        _name = name;
        _path = path;
        _embedded = embedded;
    }

    public EmbeddedFormFieldBuilder Label(string label) { _label = label; return this; }
    public EmbeddedFormFieldBuilder Description(string description) { _description = description; return this; }
    public EmbeddedFormFieldBuilder Disabled(bool disabled = true) { _disabled = disabled; return this; }
    public EmbeddedFormFieldBuilder ReadOnly(bool readOnly = true) { _readOnly = readOnly; return this; }
    public EmbeddedFormFieldBuilder Presentation(EmbeddedFormPresentation presentation) { _presentation = presentation; return this; }

    internal EmbeddedFormFieldDefinition Build() =>
        new(
            Name: _name,
            PropertyPath: _path,
            Label: _label ?? _name,
            Description: _description,
            Disabled: _disabled,
            ReadOnly: _readOnly,
            EmbeddedForm: _embedded,
            Presentation: _presentation
        );
}

// ==========================================================
// 7) PropertyPath helper
// ==========================================================

internal static class PropertyPath
{
    public static string FromExpression<TModel, TValue>(Expression<Func<TModel, TValue>> expr)
    {
        Expression body = expr.Body;
        if (body is UnaryExpression ue) body = ue.Operand;

        if (body is not MemberExpression me)
            throw new ArgumentException("Binding must be a property access like x => x.Name or x => x.Address.City");

        var parts = new Stack<string>();
        Expression? cur = me;
        while (cur is MemberExpression m)
        {
            parts.Push(m.Member.Name);
            cur = m.Expression;
        }
        return string.Join('.', parts);
    }
}

